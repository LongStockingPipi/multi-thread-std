Java内存模型（Java Memory Model）

Volatile、synchronized、Lock等关键字、工具类的原理都是JMM

1. 重排序
    在线程中两行代码的执行顺序与在Java文件中定义顺序不一致，代码指令并不是严格的按照代码语句顺序执行的，这就是重排序。
    重排序是一种指令优化
    两种情况：
        1.1. 编译器优化（jvm、jit等）
        1.2. CPU指令重排
    重排序的好处：提高执行效率

2. 可见性
    可见性问题：
    CPU有多级缓存，导致读的数据过期；高速缓存的容量比主内存小，但是速度仅次于寄存器，所以在CPU和主内存之间多了Cache层。
    每一个核心都会将自己需要的数据读到独占缓存中，数据修改之后也是写入缓存中，然后等待刷新到主内存。因此导致有些核心读到的值是过期的值。
    Volatile可以避免可见性问题，当线程1在修改变量a之后，一旦线程2读取变量a的内容，就会强制将a在线程1工作内存的内容放到主内存。


3. 原子性