Java内存模型（Java Memory Model）

Volatile、synchronized、Lock等关键字、工具类的原理都是JMM

1. 重排序
    在线程中两行代码的执行顺序与在Java文件中定义顺序不一致，代码指令并不是严格的按照代码语句顺序执行的，这就是重排序。
    重排序是一种指令优化
    两种情况：
        1.1. 编译器优化（jvm、jit等）
        1.2. CPU指令重排
    重排序的好处：提高执行效率

2. 可见性
    JMM的抽象：
    主内存与本地内存：
    Thread1 -> Working Memory -> Buffer
                                        -> Main Memory
    Thread2 -> Working Memory -> Buffer
    本地内存指的是JMM的一个抽象，包括寄存器、一级缓存、二级缓存


    JMM规定：
    1. 所有的变量都存储在主内存中，同时每个线程也有自己独立的工作内存，工作内存中的变量内容是主内存中的拷贝。
    2. 线程不能直接读写主内存的变量，只能操作自己工作内存中的变量，然后再同步到主内存中。
    3. 主内存是线程共享的，工作内存是线程独享的，线程之间的通信只能通过主内存中转完成。
    所有的共享变量存在于主内存中，每个线程有自己的本地内存，而且线程读写共享数据也是通过本地内存交换的，所以才导致了可见性问题。


    可见性问题：
    CPU有多级缓存，导致读的数据过期；高速缓存的容量比主内存小，但是速度仅次于寄存器，所以在CPU和主内存之间多了Cache层。
    每一个核心都会将自己需要的数据读到独占缓存中，数据修改之后也是写入缓存中，然后等待刷新到主内存。因此导致有些核心读到的值是过期的值。
    Volatile可以避免可见性问题，当线程1在修改变量a之后，一旦线程2读取变量a的内容，就会强制将a在线程1工作内存的内容放到主内存。


    Happens-Before原则：
    该原则使用来解决可见性问题的，在时间上，动作A发生在动作B之前，B保证能看到A。即：操作A如果发生在操作B之前，那么A对于B是可见的。
    Happens-Before的场景：
    1. 单线程原则
    2. 锁操作（synchronized和Lock）
    3. volatile变量
    4. 线程启动
    5. 线程join()
    6. 中断
    7. 遵守Happens-Before原则的工具类：
        7.1. 线程安全的容器get之前一定能看到put等写操作；
        7.2. CountDownLatch
        7.3. Semaphore
        7.4. Future
        7.5. 线程池：本质上与线程启动一样
        7.6. CyclicBarrier


    Volatile关键字：
    Volatile是一种轻量级的同步机制，不会发生上下文切换。但是由于本身无锁，无法做到原子性和互斥行，因此做不到像synchronized这种的原子同步。
    Volatile适用场合：
        1. boolean flag：对于一个线程共享变量始终只有赋值操作。（赋值具有原子性，Volatile具有可见性，因此线程安全）；
        2. 触发器：定义Volatile变量放到业务代码最后，其它线程一旦感知变量变化，则说明线程之前的代码也具有可见性，同样可以让其它线程安全使用；
                 Synchronized关键字也有这个作用，在退出Synchronized代码块后，Synchronized内部的代码以及其之前的代码都具有可见性。
    Volatile的作用：
        1. 可见性，读入一个Volatile变量之前，需要先使相应的本地缓存失效，这样必须到主内存中读取最新的值；写入一个Volatile变量会立即刷入到主内存。
        2. 禁止指令重排序优化。
        3. Volatile可以保证long、double赋值是原子的。


3. 原子性
    一系列曹操作，要么全部执行成功，要么全部执行失败，不会出现执行一半的情况。
    Java中的原子操作：
        1. 除了long、double之外的基本类型赋值；
        2. 所有引用类型（reference）的赋值操作（无论机器是32位还是64位）；
        3. java.concurrent.Atomic.*下的所有类的原子操作；